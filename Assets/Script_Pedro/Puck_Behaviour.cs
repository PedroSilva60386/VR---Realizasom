using System;using Oculus.Interaction.Input;using OVR;using TMPro;using Unity.XR.CoreUtils;using UnityEngine;using UnityEngine.InputSystem.XR.Haptics;using UnityEngine.Serialization;using UnityEngine.XR;using InputDevice = UnityEngine.InputSystem.InputDevice;using Random = UnityEngine.Random;public class Puck_Behaviour : MonoBehaviour{    //Table Walls    [SerializeField] private Transform leftWall;    [SerializeField] private Transform rightWall;    [SerializeField] private Transform topWall;    [SerializeField] private Transform bottomWall;    [FormerlySerializedAs("RightTopSideCorner")] [SerializeField] private Transform rightTopSideCorner;    [FormerlySerializedAs("LeftTopSideCorner")] [SerializeField] private Transform leftTopSideCorner;    [SerializeField] private float forceMultiplier = 5f;    [SerializeField] private string inputAction = "Fire1"; // Change to the desired action    [SerializeField] private GameObject paddle;    [SerializeField] private AudioSource bump;    [SerializeField] private AudioSource wind;    [SerializeField] private GameObject botPaddle;    //[SerializeField]    private Vector3 _playerForce ;    [SerializeField] private float playerForceBot;        //Puck's Rigid Body component    private Rigidbody _rb;    public bool _colisionPaddle;    public bool _collisionBotSide;        private void Start()    {        _rb = GetComponent<Rigidbody>();        _colisionPaddle = false;        _collisionBotSide = false;        //_paddleRb = paddle.GetComponent<Rigidbody>();    }        //Puck's first velocity value, and friction behaviour    private void FixedUpdate()    {        if (Input.GetButtonDown(inputAction))        {            var v = new Vector3(Random.Range(0f,0.5f), 0,Random.Range(0f,0.5f) ) * forceMultiplier;            _rb.AddForce(v);        }        var vv = _rb.velocity;        _rb.velocity = vv * 0.999f;        ChangePitch();        ChangePan();        //var puckX = transform.position.x;        //HapticFeedBack(puckX, leftWall, rightWall, 0.2f);            }        private void OnDrawGizmos()    {            //Gizmos.DrawLine(transform.position, transform.position + newVel.normalized);        //Gizmos.DrawLine(paddle.transform.position, paddle.transform.position - paddleVel.normalized);     //    var worldMaxPos = ( rightWall.position);     //    var worldMinPos = ( leftWall.position);     //    var worldPuckPosition = (transform.position);     //    Gizmos.DrawSphere(worldPuckPosition, 1.0f);     //   Gizmos.DrawSphere(worldMaxPos, 0.3f);     //   Gizmos.DrawSphere(worldMinPos, 0.3f);    }    private void ChangePan()    {        var worldMaxPos = (rightWall.position).x;        var worldMinPos = ( leftWall.position).x;        var worldPuckPosition = ( transform.position).x;        var distanceWalls = Math.Abs(worldMaxPos - worldMinPos);             var distancePaddle = worldMaxPos - worldPuckPosition;        var puckX01 = distancePaddle / distanceWalls;              puckX01 = Mathf.Max(puckX01, 0.0f);        puckX01 = Mathf.Min(puckX01, 1.0f);        wind.panStereo = Mathf.Lerp(1.0f,-1.0f,puckX01);    }    // ReSharper disable Unity.PerformanceAnalysis    private void ChangePitch()    {        var worldMaxPos = ( topWall.position).z;        var worldMinPos = ( bottomWall.position).z;        var worldPuckPosition = ( transform.position).z;        var distanceWalls = Math.Abs(worldMaxPos - worldMinPos);        var distancePaddle = worldMaxPos - worldPuckPosition;        var puckZ01 = distancePaddle / distanceWalls;        puckZ01 = Mathf.Max(puckZ01, 0.0f);        puckZ01 = Mathf.Min(puckZ01, 1.0f);        wind.pitch = Mathf.Lerp(0.5f, 1.5f, puckZ01);    }    //Collision Detection    private void OnCollisionEnter(Collision collision)    {        Debug.Log("Entered collision with " + collision.gameObject.name);        if (collision.gameObject.name == rightWall.gameObject.name)        {            var v = _rb.velocity;            _rb.velocity = new Vector3(-v.x, v.y, v.z);            bump.Play();        }                if (collision.gameObject.name == leftWall.gameObject.name)        {            var v = _rb.velocity;            _rb.velocity = new Vector3(-v.x, v.y, v.z);            bump.Play();        }                        if (collision.gameObject.name == bottomWall.gameObject.name)        {            //Audio Source da bottom Wall            _collisionBotSide = true;            var ba = bottomWall.gameObject.GetComponent<AudioSource>();            ba.Play();            ResetGame();        }                        if (collision.gameObject.name == topWall.gameObject.name)        {            //Audio Source da Top Wall            var ba = topWall.gameObject.GetComponent<AudioSource>();            ba.Play();            ResetGame();        }        if (collision.gameObject.name == rightTopSideCorner.gameObject.name)        {            bump.Play();            var contact = collision.contacts[0];            var reflectedVelocity = Vector3.Reflect(_rb.velocity, contact.normal);            _rb.velocity = reflectedVelocity * 2.0f;                    }        if (collision.gameObject.name == leftTopSideCorner.gameObject.name)        {            bump.Play();            var contact = collision.contacts[0];            var reflectedVelocity = Vector3.Reflect(_rb.velocity, contact.normal);            _rb.velocity = reflectedVelocity * 2.0f;                    }        // ReSharper disable once InvertIf        if (collision.gameObject.name == paddle.gameObject.name)        {            var ps = paddle.gameObject.GetComponent<AudioSource>();            ps.Play();            var contact = collision.contacts[0];            var reflectedVelocity = Vector3.Reflect(_rb.velocity, contact.normal);            _rb.velocity = reflectedVelocity * 2.0f;            //_rb.velocity = reflectedVelocity * _playerForce.magnitude;            reflectedVelocity.y = 0f;            _colisionPaddle = true;            HapticFeedBack(0, leftWall, rightWall, 0.5f);        }        if (collision.gameObject.name == botPaddle.gameObject.name)        {            var ps = botPaddle.gameObject.GetComponent<AudioSource>();            ps.Play();            var contact = collision.contacts[0];            var reflectedVelocity = Vector3.Reflect(_rb.velocity, contact.normal);            _rb.velocity = reflectedVelocity * playerForceBot;            reflectedVelocity.y = 0f;        }    }    private void HapticFeedBack(float x, Transform lw, Transform rw, float amp)    {        if (x >= lw.position.x + 0.5f && x <= rw.position.x - 0.5f)        {            Tremor(0,amp,0.2f);        }        if(_colisionPaddle)        {            Tremor(0,amp,0.1f);        }                }    private void Tremor(uint channel, float amp, float duration)    {        var rightDevice = InputDevices.GetDeviceAtXRNode(XRNode.RightHand);        rightDevice.SendHapticImpulse(channel, amp, duration);        // var leftDevice = InputDevices.GetDeviceAtXRNode(XRNode.LeftHand);        // leftDevice.SendHapticImpulse(channel, amp, duration);    }    private void ResetGame()    {        transform.position = new Vector3(0,0.8f,0);        _rb.velocity = Vector3.zero;        }}